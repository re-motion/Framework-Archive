using System;
using Rubicon.Collections;
using Rubicon.Data.DomainObjects.Infrastructure.Interception;
using Rubicon.Reflection;
using Rubicon.Utilities;
using System.Reflection;

namespace Rubicon.Data.DomainObjects.Infrastructure
{
  /// <summary>
  /// Provides functionality for creating instances of DomainObjects which intercept property calls.
  /// </summary>
  public class InterceptedDomainObjectFactory : IDomainObjectFactory
  {
    private readonly ModuleManager _scope;
    private readonly InterlockedCache<Type, Type> _typeCache = new InterlockedCache<Type, Type> ();

    /// <summary>
    /// Initializes a new instance of the <see cref="InterceptedDomainObjectFactory"/> class.
    /// </summary>
    /// <param name="assemblyDirectory">The directory to save the generated assemblies to. This directory is only used when
    /// <see cref="SaveGeneratedAssemblies"/> is used.</param>
    public InterceptedDomainObjectFactory (string assemblyDirectory)
    {
      _scope = new ModuleManager (assemblyDirectory);
    }

    /// <summary>
    /// Saves the assemblies generated by the factory and returns the paths of the saved manifest modules.
    /// </summary>
    /// <returns>The paths of the manifest modules of the saved assemblies.</returns>
    public string[] SaveGeneratedAssemblies ()
    {
      return _scope.SaveAssemblies ();
    }

    /// <summary>
    /// Gets a domain object type assignable to the given base type which intercepts property calls.
    /// </summary>
    /// <param name="baseType">The base domain object type whose properties should be intercepted.</param>
    /// <returns>A domain object type which intercepts property calls.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="baseType"/> is <see langword="null"/>.</exception>
    /// <exception cref="ArgumentTypeException"><paramref name="baseType"/> cannot be assigned to <see cref="DomainObject"/>.</exception>
    public Type GetConcreteDomainObjectType (Type baseType)
    {
      ArgumentUtility.CheckNotNullAndTypeIsAssignableFrom ("baseType", baseType, typeof (DomainObject));

      return _typeCache.GetOrCreateValue (baseType, CreateConcreteDomainObjectType);
    }

    private Type CreateConcreteDomainObjectType (Type baseType)
    {
      ArgumentUtility.CheckNotNull ("baseType", baseType);

      try
      {
        TypeGenerator generator = _scope.CreateTypeGenerator (baseType);
        return generator.BuildType ();
      }
      catch (NonInterceptableTypeException ex)
      {
        throw new ArgumentException (ex.Message, "baseType", ex);
      }
    }

    /// <summary>
    /// Checkes whether a given domain object type was created by this factory implementation (but not necessarily the same factory instance).
    /// </summary>
    /// <param name="type">The type to be checked.</param>
    /// <returns>True if <paramref name="type"/> was created by an instance of the <see cref="InterceptedDomainObjectFactory"/>; false otherwise.</returns>
    /// <exception cref="ArgumentNullException">The <paramref name="type"/> parameter was null.</exception>
    public bool WasCreatedByFactory (Type type)
    {
      ArgumentUtility.CheckNotNull ("type", type);
      return typeof (IInterceptedDomainObject).IsAssignableFrom (type);
    }

    /// <summary>
    /// Returns a construction object that can be used to instantiate objects of a given interceptable type.
    /// </summary>
    /// <typeparam name="TMinimal">The type statically returned by the construction object.</typeparam>
    /// <param name="type">The exatct interceptable type to be constructed; this must be a type returned by <see cref="GetConcreteDomainObjectType"/>.
    /// <typeparamref name="TMinimal"/> must be assignable from this type.</param>
    /// <returns>A construction object, which instantiates <paramref name="type"/> and returns <typeparamref name="TMinimal"/>.</returns>
    /// <exception cref="ArgumentNullException">The <paramref name="type"/> argument is null.</exception>
    /// <exception cref="ArgumentTypeException"><paramref name="type"/> is not the same or a subtype of <typeparamref name="TMinimal"/>.</exception>
    /// <exception cref="ArgumentException"><paramref name="type"/> wasn't created by this kind of factory.</exception>
    public IFuncInvoker<TMinimal> GetTypesafeConstructorInvoker<TMinimal> (Type type)
    {
      ArgumentUtility.CheckNotNullAndTypeIsAssignableFrom ("type", type, typeof (TMinimal));
      if (!WasCreatedByFactory (type))
        throw new ArgumentException (
            string.Format ("The type {0} was not created by InterceptedDomainObjectFactory.GetConcreteDomainObjectType.", type.FullName), "type");
      return TypesafeActivator.CreateInstance<TMinimal> (type, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
    }

    /// <summary>
    /// Prepares an instance which has not been created via <see cref="GetTypesafeConstructorInvoker{TMinimal}"/> for use. This operation
    /// is a no-op for this implementation of <see cref="IDomainObjectFactory"/>.
    /// </summary>
    /// <param name="instance">The instance to be prepared</param>
    /// <exception cref="ArgumentNullException">The <paramref name="instance"/> argument is null.</exception>
    /// <exception cref="ArgumentException"><paramref name="instance"/> is not of a type created by this kind of factory.</exception>
    public void PrepareUnconstructedInstance (DomainObject instance)
    {
      ArgumentUtility.CheckNotNull ("instance", instance);
      Type type = ((object)instance).GetType ();
      if (!WasCreatedByFactory (type))
        throw new ArgumentException (
            string.Format ("The domain object's type {0} was not created by InterceptedDomainObjectFactory.GetConcreteDomainObjectType.",
              type.FullName), "instance");
    }
  }
}