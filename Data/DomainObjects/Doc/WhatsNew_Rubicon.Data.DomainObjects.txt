1.7.13.0
========

- Folgende Framework-interne Methoden/Properties in BindableDomainObject und BindableSearchObject 
  wurden entweder zu privaten Methoden/Properties oder zu expliziten Interface-Implementierungen umgewandelt, 
  um das Interface einfacher zu machen:
  * GetBusinessObjectProperty -> privat
  * BusinessObjectClass -> explizite Interface-Implementierung
  * this[IBusinessObjectProperty] Indexer -> explizite Interface-Implementierung
  * this[string] Indexer -> explizite Interface-Implementierung
  * GetPropertyString (string) -> explizite Interface-Implementierung
  * GetPropertyString (IBusinessObjectProperty) -> explizite Interface-Implementierung 
  * GetPropertyString (IBusinessObjectProperty, string) -> explizite Interface-Implementierung -> Methode ist jetzt nicht mehr virtual!
  * GetProperty (string) -> explizite Interface-Implementierung  
  * GetProperty (IBusinessObjectProperty) -> explizite Interface-Implementierung  
  * SetProperty (string, object) -> explizite Interface-Implementierung  
  * SetProperty (IBusinessObjectProperty, object) -> explizite Interface-Implementierung  

- Bei Property IBusinessObjectWithIdentity.UniqueIdentifier wurde EditorBrowsable = Never entfernt, damit bei einem expliziten Cast auf
  das Interface die Property in der IntelliSense aufscheint.
  
- Da die folgenden Framework-Properties der DomainObject-Klasse normalerweise nicht auf einer GUI-Maske angezeigt werden sollen, 
  werden sie jetzt vom Property Picker zur Design Time nicht mehr angezeigt:
  * IsDiscarded
  * State
  * ClientTransaction
  * ID
  
    
1.7.12.0
========

- Klassen DomainObject und ClientTransaction stellen neue Events zur Verfügung:
  * RollingBack
  * RolledBack

- IClientTransactionExtension.RollingBack und IClientTransactionExtension.RolledBack bekommen jetzt ebenfalls 
  die betroffenen DomainObjects übergeben.

- Mapping.xml:
  * Die Reihenfolge der Subelemente von class- und property-Elementen ist ab sofort frei wählbar. 
    -> Beim Element relationProperty bleibt die Reihenfolge relevant, damit das Schema deterministisch bleibt.
  * Das Element "column" ist bei property-Elementen nun optional. Wird es ausgelassen, wird der selbe Wert wie in propertyName angenommen.
    -> Bei relationProperties muss "column" weiterhin angegeben werden, damit das Framework erkennt welche Seite einer Beziehung den Foreign Key speichert.
    
- MaxLength Element ist jetzt im Mapping optional:
  * Damit können string-Eigenschaften beliebiger Länge gespeichert werden.
  * DoGen generiert für diesen Fall Spalten vom Typ text. Achtung: Diese können im SQL Server nicht bei einer Query mit dem = Operator abgefragt werden!     

- MandatoryRelationNotSetException beinhaltet ab sofort 2 neue Properties:
  * DomainObject = Objekt bei dem die MandatoryRelationNotSetException aufgetreten ist.
  * PropertyName = Eigenschaft bei der die MandatoryRelationNotSetException aufgetreten ist.
  
- Neue Methode in ClientTransaction:
  * bool HasChanged ... Gibt zurück, ob sich mindestens ein Objekt im Zuge dieser Transaktion geändert hat.
  
- Änderung des Verhaltens beim Laden der Konfigurationsdateien (Mapping, StorageProviders, Queries):
  Wurde ein AppSetting (z.B. Rubicon.Data.DomainObjects.Mapping.ConfigurationFile) 
  angegeben und existiert die angegebene Datei nicht, wird sofort ein Fehler gemeldet und kein Fallback mehr
  auf den ExecutingAssemblyPath durchgeführt. Wurde kein AppSetting angegeben, ist das Verhalten wie bisher.
  
      
1.7.11.0
========

- DOGen:
  * Die erstellten Views für abstrakte Klassen sind jetzt mit SQL Server 2000 kompatibel.
  * Neue optionale Kommandozeilen-Parameter mappingFile und storageProvidersFile, mit denen man eigene Dateinamen für die 
    Konfigurationsdateien angeben kann.
  * Klassen werden nach dem neuen Styleguide erstellt.


1.7.10.0
========

- Reihenfolge der Events beim Löschen eines Objekts geändert:
  ALT: Deleting, RelationChanging, Deleted, RelationChanged
  NEU: Deleting, RelationChanging, RelationChanged, Deleted

- Reihenfolge der Events beim Einfügen in eine 1:n Beziehung geändert, ist jetzt identisch mit Ersetzen eines Objekts:
  ALT: Neues Objekt (n-Seite), altes Objekt (1-Seite) des neuen Objektes, bestendes Objekt (1-Seite)
  NEU: Neues Objekt (n-Seite), bestendes Objekt (1-Seite), altes Objekt (1-Seite) des neuen Objektes

- Auf der ClientTransaction können Extensions registriert werden. Dafür gibt es ein neues Interface IClientTransactionExtension und 
  eine neue Property ClientTransaction.Extensions. 
  Die Extensions werden über die folgende Vorgänge notifiziert:
  * Instanzieren neuer Objekte
  * Laden von Objekten
  * Löschen von Objekten
  * Auslesen und Ändern von Properties
  * Auslesen und Ändern von Beziehungen
  * Ausführen von Queries
  * Commit und Rollback
  

1.7.9.0
=======

- Event ClientTransaction.Loaded wird nicht mehr gefeuert, wenn beim Navigieren über eine Beziehung kein Objekt geladen wird.


1.7.7.0
=======

- Breaking Change: Property-Changed Events (PropertyValue, PropertyValueCollection, DataContainer, DomainObject) bekommen in 
  neuen PropertyChangeEventArgs jetzt zusätzlich den alten und neuen Wert übergeben => Changing- und Changed-Events
  mit neuem Delegate PropertyChangeEventHandler vereinheitlicht. 
  Notwendige Schritte für Upgrade:
    * Alle Vorkommnisse von PropertyChangingEventHandler und PropertyChangedEventHandler durch PropertyChangeEventHandler ersetzen.
    * Alle Vorkommnisse von PropertyChangingEventArgs und PropertyChangedEventArgs durch PropertyChangeEventArgs ersetzen.
  
- Für ClientTransaction-Extension-Infrastruktur wurde die Event-Reihenfolge von DataContainer.PropertyChanged und DomainObject.PropertyChanged geändert.
  ALT: DomainObject vor DataContainer.
  NEU: DataContainer vor DomainObject.

  
1.7.6.0
=======

- Mapping, StorageProviders, Queries:
  Die XML Schema Dateien Mapping.xsd, StorageProviders.xsd und Queries.xsd sind jetzt als Ressource in der Assembly
  Rubicon.Data.DomainObjects enthalten und müssen daher nicht mehr im bin Verzeichnis der Projekte liegen.

  Damit entfallen auch die folgenden web.config Einträge:
    * Rubicon.Data.DomainObjects.Mapping.SchemaFile
    * Rubicon.Data.DomainObjects.Persistence.Configuration.SchemaFile
    * Rubicon.Data.DomainObjects.Queries.Configuration.SchemaFile

- Concrete Table Inheritance:
  Hat eine Vererbungshierarchie abstrakte Basisklassen können deren abgeleitete Klassen in unterschiedliche Tabellen 
  persistiert werden. Dazu wird bei den abstrakten Klassen im Mapping kein <entity> Element angegeben. Jede Tabelle enthält
  dabei auch die Spalten der abstrakten Basisklassen.
  
  Bei der Generierung der SQL Skripts mit DoGen wird dies berücksichtigt. Weiters wird eine View pro Klasse erstellt, 
  die alle Objekte dieser und ihrere abgeleiteten Klassen zurückgibt. Diese können für Datenbankabfragen verwendet werden.
  
- Neue Methode ClassDefinition.IsSameOrBaseClassOf eingeführt.

- Beim Setzen einer Beziehung über SetRelatedObject wird nun auch der Typ des übergebenen Objekts kontrolliert.


1.7.2.0
=======

- Mapping: 
  Für die Implementierung von Concrete Table Inheritance dürfen ab dieser Version Eigenschaften zweier Klassen, die Teil 
  der selben Vererbungshierarchie sind, nicht die selben Spaltennamen verwenden. Dies gilt auch für Objektklassen, die 
  sich in parallelen Vererbungszweigen befinden.


1.7.1.0
=======

- Im Falle von ungültigen Datenbankwerten bei einer FK-Spalte wurden die Fehlermeldungen verbessert.


1.4.37.0
========

- Rubicon.Data.DomainObject.CommonCollection.CopyTo:
  Lieferte eine ArgumentException, wenn man versucht hat, eine leere Collection in ein leeres Array zu kopieren => Behoben.
  

1.4.26.0
========

- Rubicon.Data.DomainObjects.Mapping.MappingConfiguration:
  Hat einen neuen Konstruktor-Parameter resolveTypes. Wird dieser auf false gesetzt, wird das gesamte Mapping geladen,
  aber keine .NET-Typen aufgelöst. Dieses Feature ist vor allem für Codegeneratoren sinnvoll, die für das Generieren
  die MappingConfiguration nutzen. Die Supporter-Klassen in den Namespaces Rubicon.Data.DomainObjects.Mapping und 
  Rubicon.Data.DomainObjects.ConfigurationLoader wurden ebenfalls entsprechend angepasst.


1.4.25.0
========

- Rubicon.Data.DomainObjects.ObjectBinding.Web.DomainObjectDataSourceControl:
  Im Build für .NET 2.0 wird jetzt auch der Designer für Web-Projekte und Web-Sites von Visual Studio 2005 korrekt unterstützt. 


1.4.10.0
========

- Rubicon.Data.DomainObjects.Web.ExecutionEngine.WxeTransactedFunction:
  Neue public property "Transaction", die eine Referenz auf die aktuelle ClientTransaction zurückgibt.

- BREAKING CHANGE: Rubicon.Data.DomainObjects.Web.ExecutionEngine.TransactionMode:
  Umbenannt in WxeTransactionMode, damit es keinen Konflikt mehr mit Property TransactionMode auf WxeTransactedFunction gibt.


1.4.9.0
=======

- Rubicon.Data.DomainObjects.Web.ExecutionEngine.WxeTransactedFunction:
  Neue Factory-Method CreateWxeTransaction (bool, bool) für das Einhängen von 
  eigenen WxeTransactions und damit von eigenen projekt-spezifischen ClientTransactions.


1.3.28.0
========

- Rubicon.Data.DomainObjects.DomainObjectCollection:
  * Contains (DomainObject) ist jetzt obsolete. Analoge Funktinalität bietet ContainsObject (DomainObject). In den häufigsten Anwendungsfällen
    sollten jedoch Aufrufe von Contains (domainObject) auf Contains (domainObject.ID) geändert werden.
  * Die DomainObjectCollection-Methoden/Properties Combine, this[int], Add und Insert verwenden jetzt Contains (domainObject.ID),
    um eine konsistente Verhaltensweise bei der Verwendung von mehreren ClientTransactions zu erzielen.
  * this[int] liefert jetzt eine verständlichere Fehlermeldung, wenn das übergebene DomainObject bereits in der Collection ist.
- Rubicon.Data.DomainObjects.Queries.QueryManager unterstützt jetzt offiziell Stored Procedures. Stored Procedures mit Parameter müssen exec verwenden!


1.3.21.0
========

- Neues Attribut Rubicon.Data.DomainObjects.ObjectBinding.UndefinedEnumValueAttribute für enum Typen:
  Das Attribut kann für Enums verwendet werden, die im DomainModel Pflicht sind, in Suchmasken jedoch optional sein können.
- Rubicon.Data.DomainObjects.ObjectBinding.IsRequiredAttribute:
  Setter von IsRequired entfernt und Klasse sealed gesetzt.
- Rubicon.Data.DomainObjects.ObjectBinding.ItemTypeAttribute:
  Setter von ItemType entfernt und Klasse sealed gesetzt.
- Rubicon.Data.DomainObjects.ObjectBinding.DateTypeAttribute:
  Setter von DateType entfernt und Klasse sealed gesetzt.
  

1.3.20.0
========

- RPF und RPA sind vollständig serialisierbar.
- Rubicon.Data.DomainObjects.ObjectBinding.BindableSearchObject: Property BusinessObjectClass gibt jetzt korrekterweise eine SearchObjectClass zurück.
- DOGen: Neuer Parameter "/serializable" um bei allen generierten Klassen das "[Serializable]" Attribut zu vergeben.

1.3.19.0
========

- Rubicon.Data.DomainObjects.CommonCollection hat neue Methode BaseContains, die zusätzlich zum Key object.Equals verwendet, um
  bei reference types zu prüfen, ob die übergebene Referenz Teil der Collection ist. 
  Für folgende Collections hat sich somit die Semantik der Contains-Overloads mit dem 
  Collection-Element (z.B. Contains (DataContainer), Contains (DomainObject)) geändert:
  * DataContainerCollection
  * RelationEndPointCollection
  * DomainObjectCollection
  * ClassDefinitionCollection
  * PropertyDefinitionCollection
  * RelationDefinitionCollection
  * StorageProviderDefinitionCollection
  * StorageProviderCollection
  * PropertyValueCollection
  * QueryDefinitionCollection
  * QueryParameterCollection
  
- Rubicon.Data.DomainObjects.Persistence.Configuration.StorageProviderDefinition:
  Property StorageProviderDefinitionID ist jetzt obsolet. In Zukunft sollte neue Property ID verwendet werden.

- Rubicon.Data.DomainObjects.Persistence.StorageProvider:
  Property StorageProviderDefinition in Definition umbenannt und visibility von protected auf public geändert.  

- Rubicon.Data.DomainObjects.Queries.Configuration.QueryDefinition:
  Property QueryID ist jetzt obsolet. In Zukunft sollte neue Property ID verwendet werden.

- Rubicon.Data.DomainObjects.Queries.IQuery:
  Property QueryID in ID umbenannt.
    
- Rubicon.Data.DomainObjects.Queries.Query:
  Property QueryID ist jetzt obsolet. In Zukunft sollte neue Property ID verwendet werden.
  
- Als Vorbereitung für die Serialisierungsfähigkeit von Rubicon.Data.DomainObjects notifizieren sich Objekte
  innerhalb des Frameworks nicht mehr über Events, sondern über eigene interne Methoden. Grund dafür ist, 
  dass .NET 1.1 keine Delegates serialisiert, die non-public methods (das bedeutet private, protected, internal) referenzieren. 
  
  
1.3.18.0
========

- Rubicon.Data.DomainObjects.Queries.QueryParameter:
  Value und ParameterType verfügen jetzt auch über einen Setter.


1.3.16.0
========

- Rubicon.Data.DomainObjects.ObjectID:
  * Klasse wurde auf sealed gesetzt.
  * Konstruktor-Overloads für Guid-, int- und sting-values entfernt.
  * Konstruktur-Overload für object-values von protected auf public geändert => CheckValue überprüft jetzt korrekten Typ.
  * Konstrukor verwendet StorageProvderDefinition, um zu prüfen, ob der StorageProvider der zugeordneten ClassDefinition
    den übergebenen value als object identifier unterstützt.

- Rubicon.Data.DomainObjects.Persistence.Configuration.StorageProviderDefinition:
  * Neue abstrakte Methode IsIdentityTypeSupported
  * Neue Methode CheckIdentityType, die eine IdentityTypeNotSupportedException wirft, 
    wenn übergebener Typ nicht als object identifier unterstützt wird.    

- Rubicon.Data.DomainObjects.Persistence:
  * Neue Exception ConverterException eingeführt.
  * ValueConverter gesplittet -> ValueConverterBase, ValueConverter -> Werfen statt RdbmsProviderExceptions ConverterExceptions.
  * Weiters kann ValueConverterBase nun auch beliebige string-Values in ihren korrekten Datentyp umwandeln.
  * Neues Interface IDataContainerFactory abstrahiert wie ein StorageProvider DataContainers erzeugt.
  * RdbmsProvider überprüft nicht mehr übergebene ObjectIDs, da für die Prüfung die ObjectID selbst verantwortlich ist.
  * RdbmsProvider definiert neue Factory-Methode CreateDataContainerFactory.
  * RdbmsProviderDefinition implementiert IsIdentityTypeSupported.
  * StorageProvider definiert neue protected Methode CheckQuery.
  
1.3.11.0
========

- Rubicon.Data.DomainObjects:
  * Der Konstruktor von QueryDefinition gibt bei fehlerhaften Konstruktorparametern im Exception-Text als Zusatzinformation 
    die queryID mit aus.
  * Neue public Property 'DomainObject.ClientTransaction'.
  * Beim Erzeugen eines neuen DomainObjects, das nicht im Mapping eingetragen ist, wird statt einer ArgumentNullException 
    eine MappingException geworfen.
  
- Rubicon.Data.DomainObjects.ObjectBinding:
  * ReferenceProperty.SearchAvailableObjects verwendet jetzt die ClientTransaction des übergebenen DomainObjects. Wenn das 
    übergebene Objekt kein DomainObject ist, wird ClientTransaction.Current verwendet.
  * Neue Assembly 'Rubicon.Data.DomainObjects.ObjectBinding.UnitTests'


1.3.9.0
=======

- Neue Exception ClientTransactionsDifferException: Wird von DomainObject, DomainObjectCollection und ClientTransaction geworfen,
  wenn Schreiboperationen auf Objekten mit unterschiedlicher ClientTransaction durchgeführt werden.

- Rubicon.Data.DomainObjects.CodeGenerator.Console (DOGen):
  Unterstützt den neuen Datentyp 'binary'. Im SQL Skript wird eine Spalte vom Datentyp 'image' erstellt, im generierten
  C# code eine Property vom Typ byte[].


1.3.8.0
=======

- Rubicon.Data.DomainObjects:
  Neuer Datentyp 'binary' im mapping.xsd eingeführt. Dieser dient zum Speichern von binären Daten (byte arrays) in BLOBs. 
  'MaxLength' wird für 'binary' unterstützt, ist aber optional.
  Neue Methode 'DomainObject.GetBytes ()' zum typisierten Lesen von byte arrays.
  'DomainObject.IsNull' und 'DomainObject.IsNullOrEmpty' unterstützen den neuen Datentyp.
  

1.3.7.0
=======

- Neue static property: ClientTransaction.HasCurrent eingeführt.
- Neue Assembly Rubicon.Data.DomainObjects.Web: Enthält WxeTransactedFunction mit WxeTransaction.
  Die WxeTransactedFunction verwaltet eine aktuelle ClientTransaction. Damit muss dies nicht mehr in der Applikation
  über die Session gesteuert werden. Ausserdem werden jetzt mehrere parallele Browser-Fenster direkt unterstützt.
  Subfunktionen können entweder eine neue Transaktion beginnen oder die der übergeordneten WXE-Funktion weiterverwenden.
  

1.2.43.0
========

- Rubicon.Data.DomainObjects.ObjectBinding.Web:
  * Attribut 'TagPrefix' ("dow") vergeben, da ansonsten VS-Designer eine nichtssagende Default-Präfix verwendet.
  * DomainObjectDataSourceControl: Wenn beim Einlesen des Mappings eine Exception ausgelöst wird, 
    wird jetzt keine MessageBox mehr angezeigt, sondern die Fehlermeldung in den Inhalt des Controls gerendert.
    
- Rubicon.Data.DomainObjects:
  Wird ein Objekt A, das in der aktuellen Transaktion neu angelegt wurde, im Committing-Event eines anderen Objektes B
  gelöscht, wird jetzt für Objekt A kein Committing Event mehr ausgelöst.
  

1.2.35.0
========

- Rubicon.Data.DomainObjects.ObjectBinding:
  * Wenn die Klasse, die bei einem ItemType-Attribut einer Collection-Property angegeben ist, nicht im Mapping vorkommt, wird
    jetzt eine MappingException statt einer ArgumentNullException geworfen.
  * Für Collection-Properties, die nicht im Mapping beschrieben sind, wird keine MappingException mehr ausgelöst, wenn das
    ItemType-Attribut fehlt. Per Default wird BindableDomainObject als Item-Type der Collection angenommen.
  
  
1.2.34.0
========
  
- ClassDefinition:
  * Bugfix für Beziehung in "Composite" Design Pattern: 
    1. GetMyRelationEndPointDefinitions liefert jetzt nur mehr alle Endpunkte der eigenen Klasse.
    2. GetRelationDefinitions funktioniert jetzt bei "Composite" Design Pattern richtig => Es kommt keine Exception mehr.
    3. Durch Behebung von Punkt 1 und Punkt 2 erzeugt DOGen jetzt bei "Composite" Design Patterns den richtigen Output (C# und SQL).
  * GetOppositeEndPointDefinition liefert keine Exception mehr, wenn gegenüberliegender Endpunkt nicht gefunden wird.
  * Neue Methode IsMyRelationEndPoint, die angibt, ob ein übergebener Endpunkt zu dieser Klasse gehört.
  * Neue Methode GetMandatoryRelationDefinition, die Exception liefert, wenn Beziehung nicht gefunden wird.
  * Neue Methode GetMandatoryOppositeClassDefinition, die Exception liefert, wenn gegenüberliegende Klasse nicht gefunden wird.
  * Neue Methode GetMandatoryRelationEndPointDefinition, die Exception liefert, wenn Endpunkt nicht gefunden wird. 
  * Neue Methode GetMandatoryOppositeEndPointDefinition, die Exception liefert, wenn gegenüberliegender Endpunkt nicht gefunden wird.
  * Neue Methode GetMandatoryPropertyDefinition, die Exception liefert, wenn Eigenschaft nicht gefunden wird.

- DomainObjectDataSourceControl:
  * Wird eine BocList auf ein DomainObjectDataSourceControl gebunden und zur Design Time eine Property über das GUI ausgewählt, wird eine 
    "Value cannot be null, Parameter name: classDefinition"-Exception geworfen, wenn die Objektklasse Collection-Properties beinhaltet, die
    nicht im Mapping vorkommen und das Attribut "ItemType" nicht gesetzt haben. Hier kommt jetzt eine sprechende Meldung. 
    Hinweis: In einem späteren Build wird das "ItemType"-Attribut optional sein und als ItemType "BindableDomainObject" angenommen.
    
- DomainObject und ClientTransaction Committing Events:
  * Wurde im DomainObject.Committing oder im ClientTransaction.Committing Event ein neu erzeugtes Objekt wieder gelöscht, wurde eine
    ObjectDiscardedException ausgelöst => Behoben.
  * DomainObject, DataContainer, PropertyValueCollection und PropertyValue haben neue Eigenschaft IsDiscarded.  
  
  
1.2.33.0
========

- Bugfixes DOGen:
  * Es werden jetzt auch Enums (die nicht als nested Types deklariert sind) erstellt.
  * Wenn der Typ einer Property in einem anderen Namespace liegt, wird der Typ vollqualifiziert angegeben.
  * Ein "using Rubicon.Data.DomainObjects.ObjectBinding" ist jetzt im Fileheader eingefügt.

- DomainObjectDataSourceControl:
  * Wird mapping.xml zur Design Time ausgelesen und enthält sie einen Fehler, wurde die Exception durch Visual Studio verschkluckt => 
    Lösung: Fehler abfangen und eigene MessageBox anzeigen.

- BooleanProperty:
  * GetDisplayName zeigt jetzt zusätzlich zu den englischen Texten auch lokalisierte deutsche Texte (Ja/Nein) an. 
    Hierfür gibt es eine sprachspezifische Satellite Assembly Rubicon.Data.DomainObjects.ObjectBinding.resources.dll


1.2.26.0
========

- NullableProperty
  * Liefert bei IsRequired nicht mehr _isNullable sonder base.IsRequired
  
- ReflectionPropertyFactory
  * Liefert bei IsPropertyRequired falls sonst nichts angegeben bei ReferenceTypes default false.

1.2.25.0
========

- Unterstützung für unidirektionale Beziehungen in mapping.xml:
  Element "relationProperty" nur auf einer Beziehungsseite definieren und Child-Element "oppositeClass" angeben =>
  Rubicon.Data.DomainObjects verwendet automatisch unidirektionale Beziehung => 
  Bei Änderungen werden auf dem gegenüberliegenden Objekt/Collection keine Events ausgelöst und kein State-Tracking durchgeführt.


1.2.18.0
========

- Rubicon.Data.DomainObjects.ObjectBinding: Die Property "ID" eines BindableDomainObjects scheint wieder in der IntelliSense auf. BindableDomainObject
  versteckt die Basisimplementierung von ID nicht mehr mit "new".


1.2.16.0
========

- "GOLDEN VERSION" von Rubicon.Data.DomainObjects und Rubicon.Data.DomainObjects.ObjectBinding


1.2.15.0
========

- Neue Assembly DOGen.exe eingeführt.
  Diese Assembly ist eine Konsolenanwendung zum automatischen Generieren des C# Source Codes eines Domain Models und der SQL Skripts für den 
  Datenbankaufbau.


1.2.14.0
========

- Neue Assembly Rubicon.Data.DomainObjects.CodeGenerator eingeführt.
  Diese Assembly bietet Klassen zum automatischen Generieren des C# Source Codes eines Domain Models und der SQL Skripts für den Datenbankaufbau.


1.2.13.0
========

- Klasse PerformanceCounters wurde entfernt, da die darunterliegende Windows API von Windows Server 2003 und Windows XP zum aktuellen Zeitpunkt
  einen nicht behobenen Bug aufweist. Details siehe:
  http://groups.google.at/groups?hl=de&lr=&newwindow=1&threadm=7%24tO0xvQEHA.3664%40cpmsftngxa10.phx.gbl&rnum=2&prev=/groups%3Fq%3D%2522Win32Exception%2522%2B%2522The%2Bdevice%2Bis%2Bnot%2Bready%2522%26hl%3Dde%26lr%3D%26newwindow%3D1%26selm%3D7%2524tO0xvQEHA.3664%2540cpmsftngxa10.phx.gbl%26rnum%3D2


1.2.12.0
========

- ClientTransaction.Rollback: Bei einem Rollback wurde in einer 1:n Beziehung die DomainObjectCollection durch ein neues Objekt ersetzt. 
  Jetzt wird die gleiche Objektinstanz auf den originalen Inhalt gesetzt.
- ClientTransaction.Commit: Bei einem Commit wurde in einer 1:n Beziehung die DomainObjectCollection mit dem urspünglichen Status der Beziehung 
  durch ein neues Objekt ersetzt. Jetzt wird die gleiche Objektinstanz auf den neuen Inhalt gesetzt.


1.2.11.0
========

- ClientTransaction.Rollback: Wurde nach einem Rollback zu einer 1:n Beziehung ein neues Objekt hinzugefügt/entfernt, 
  wurde der Link auf der n-Seite nicht aktualisiert => Behoben.

- Basisklasse für alle Konfigurationsklassen (Mapping, StorageProviders, Queries) eingeführt. Neue Eigenschaft ApplicationName eingeführt.

- Neue Klasse PerformanceCounters mit Methoden zum Installieren und Deinstallieren der Performance Counter eingeführt.

<= 1.2.10.0
===========

- Beta-Versionen: Sind noch nicht für den Einsatz in einer Produktionsumgebung gedacht.