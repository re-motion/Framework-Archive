<?xml version="1.0" encoding="utf-8" ?> 

<Comments>

<WorkContext>
  <Class>
    <remarks>
      <para>
        Exceptions contain a stack trace of the time the exception was thrown, so it is easy to identify the code that 
        caused the exception. However, there is no information as to which data this code was processing, or which 
        iteration
        of a certain loop caused a problem. For programs that process large amount of data and fail for specific data, 
        it 
        can be tedious to find the state or data that caused an error. 
      <para></para>
        WorkContexts provide an easy way to specify which data is currently being processed. In an exception handling 
        block,
        the current context stack can be used to get diagnostic information about the state of the application when the
        exception occured. 
      </para>
    </remarks>
    <example>
      The following example demonstrates the use of WorkContexts to provide information about the data that is currently
       being
      processed. Note the <c>using</c> statement and the call to <see cref="WorkContext.Done"/>. 
      <code><![CDATA[
void f (string[] document)
{
  try
  {
    for (int i = 0; i < document.Lenght; ++i)
    {
      using (WorkContext ctxLine = WorkContext.EnterNew ("Processing line {0}: \"{1}\".", i, line[i]))
      {
        Console.WriteLine (line[i].Trim()); // this causes a NullReferenceException if line[i] is a null reference
        ctxLine.Done();
      }
    }
}
catch (Exception e)
{
  Console.WriteLine ("Error \"{0}\" occured during:\n{1}", e.Message, WorkContext.Stack);
}
      ]]></code>
    </example>
  </Class>
  <Enter>
    <Method>
      <remarks>
        Instead of creating a new <see cref="WorkContext"/> and entering it using this method, you can use the static 
        method 
        <see cref="EnterNew"/>. Using <see cref="Enter"/> makes sense if the call is conditional, especially if you use 
        the
        methods <see cref="EnterIfDebug"/> or <see cref="EnterIfTrace"/>.
      </remarks>
    </Method>
    <Signature_Text>
      <param name="text">The description of the context.</param>
    </Signature_Text>
    <Signature_Format_Args>
      <param name="format">A string containing zero or more format items for the description of the context.</param>
      <param name="args">An array containing zero or more objects to format.</param>
    </Signature_Format_Args>
  </Enter>
  <EnableTracing>
    <remarks>
      The default value is <see langword="false"/>. You can change this value in your code, or use the 
      "Rubicon.WorkContext.EnableTracing" 
      appSettings key in your application's configuration file to set it to <see langword="true"/>.
    </remarks>
    <example>
      <code><![CDATA[
<configuration>
  <appSettings>
    <add key="Rubicon.WorkContext.EnableTracing" value="true" />
  </appSettings>
</configuration>
      ]]></code>
    </example>
  </EnableTracing>
</WorkContext>

<CommandLineParser>
  <Parameters>
    <param name="includeFirstArgument">If <see langword="true"/>, the first argument (which is usually the file name of 
    the
      program) is included, otherwise only the arguments after the first one are included.</param>
  </Parameters>
  <SplitCommandLine>
    <param name="commandLine">The command line (as available from <see cref="System.Environment.CommandLine"/>.)</param>
    <include file='include.xml' path='/Comments/CommandLineParser/Parameters/param[@name="includeFirstArgument"]' />
    <returns>An array of command line arguments.</returns>
    <remarks>
      The following rules apply:
      <list type="bullet">
        <item>Use spaces to separate arguments.</item>
        <item>Embed arguments within double quotation marks to treat them as a single argument even if they contain 
        spaces.</item>
        <item>Within double quotation marks, use two double quotation marks if you need one double quotation mark in the 
        argument.</item>
      </list>
      This resembles the logic that is applied to the arguments of the C# Main method. However, the parameters passed to
      the Main method are parsed a little bit differently in special situations, according to an unknown and undocumented 
      algorithm.
    </remarks>
    <example>
      <list type="table">
        <listheader>
          <term>Command Line</term>
          <description>Parsing Result</description>
        </listheader>
        <item>
          <term>
            Hello world!
          </term>
          <description>
            <para>
              Hello
            </para><para>
              world!
            </para>
          </description>
        </item>
        <item>
          <term>
            Hello "new world!"
          </term>
          <description>
            <para>
              Hello
            </para><para>
              new world!
            </para>
          </description>
        </item>
        <item>
          <term>
            Hello """new"" world!"
          </term>
          <description>
            <para>
              Hello
            </para><para>
              "new" world!
            </para>
          </description>
        </item>
      </list>
    </example>    
  </SplitCommandLine>
</CommandLineParser>


</Comments>